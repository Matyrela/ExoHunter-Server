name: Exoserver

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ${{ secrets.REGISTRY_HOST }}
  IMAGE_NAME: ${{ secrets.IMAGE_NAME }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - name: Login to private registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_HOST }}
          username: ${{ secrets.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      K8S_NAMESPACE: exohunter
      DEPLOYMENT_NAME: exoserver-deployment
      SERVICE_NAME: exoserver-svc
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          curl -fsSL -o kubectl "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client --output=yaml

      - name: Prepare kubeconfig (token auth)
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.K8S_CA_CRT }}" | base64 -d > $HOME/.kube/ca.crt
          cat > $HOME/.kube/config <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              certificate-authority: $HOME/.kube/ca.crt
              server: ${{ secrets.K8S_API }}
            name: exo
          contexts:
          - context:
              cluster: exo
              namespace: ${K8S_NAMESPACE}
              user: ci
            name: exo
          current-context: exo
          users:
          - name: ci
            user:
              token: ${{ secrets.K8S_TOKEN }}
          EOF
          kubectl get ns

      - name: Ensure namespace & imagePullSecret
        run: |
          kubectl create ns ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n ${K8S_NAMESPACE} create secret docker-registry registry-cred \
            --docker-server=${{ secrets.REGISTRY_HOST }} \
            --docker-username=${{ secrets.REGISTRY_USER }} \
            --docker-password='${{ secrets.REGISTRY_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply manifests
        run: |
          kubectl apply -f k8s/
          kubectl -n ${K8S_NAMESPACE} rollout status deploy/${DEPLOYMENT_NAME} --timeout=240s

      - name: Patch imagePullSecrets (idempotent)
        run: |
          kubectl -n ${K8S_NAMESPACE} patch deployment ${DEPLOYMENT_NAME} \
            --type='json' \
            -p='[{"op":"add","path":"/spec/template/spec/imagePullSecrets","value":[{"name":"registry-cred"}]}]' || true

      - name: Set image to latest & wait rollout
        run: |
          kubectl -n ${K8S_NAMESPACE} set image deployment/${DEPLOYMENT_NAME} \
            exoserver=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          kubectl -n ${K8S_NAMESPACE} rollout status deployment/${DEPLOYMENT_NAME} --timeout=240s

      - name: Show svc/ingress
        run: |
          kubectl -n ${K8S_NAMESPACE} get svc ${SERVICE_NAME} -o wide || true
          kubectl -n ${K8S_NAMESPACE} get ingress -o wide || true
